# Predicting Class Probabilities {#classification}

In our dataset, we have several categorical variables such as suicide attack, attack success, extended attack, part of multiple attacks etc with qualitative value ie. Yes/ No (1 or 0). In previous chapter, we have predicted number of attacks and fatalities for Afghanistan, Iraq and SAHEL region. In this chapter, we choose data from all the countries that are impacted by top 10 most active and violents groups and make use of cutting edge LightGBM algorithm to predict the category of target variable which will be helpful to identify and understand the causal variables behind such attacks. This is supervised machine learning approach, which means our dataset has labelled observations and the objective is to find a function that can be used to assign a class to unseen observations. 


## Evolution of Gradient Boosting Machines

In supervised learning, boosting is a commonly used machine learning algorithm due to its accuracy and efficiency. It is an ensemble model of decision trees where trees are grown sequentially i.e. each decision tree grown using the information from previously grown trees [@James_2013]. In other words, boosting overcomes the deficiencies in the decision trees by sequentially fitting the negative gradients to each new decision tree in the ensemble. Boosting method was further enhanced with optimization and as a result, Gradient Boosting Machine (GBM) came out as new approach to efficiently implement boosting method as proposed by researcher [@Friedman_2001] in his paper "Greedy Function Approximation: A Gradient Boosting Machine". GBM is also known as GBDT (Gradient Boosting Decision Tree). This approach has shown significant improvement in accuracy compared to traditional models. Although, this technique is quite effective but for every variable, boosting needs to scan all the data instances in order to estimate the information gain for all the possible splits. Eventually, this leads to increased computational complexities depending on number of features and number of data instances [@NIPS2017_6907].

To further explain this, finding optimal splits during the learning process is the most time consuming part in traditional GBDT. The GBM package in R and XGBoost implements GBDT using pre-sorted algorithm to find optimal splits [@Chen_2016; @Ridgeway_2007]. This approach requires scanning all the instances and then sorting them by feature gains. Another approach uses histogram-based algorithm to bucket continuous variables into discrete bins. This approach focuses on constructing feature histograms through discrete bins during training process instead of finding splits based on sorted feature values [@NIPS2017_6907]. XGBoost supports both histogram-based and pre-sorted algorithm. Comparatively, histogram-based approach is the most efficient in terms of training speed and RAM usage. From year 2015, XGBoost has been widely recognized in many machine learning competitions (such as on Kaggle) as one of the best gradient boosting algorithm [@Chen_2016; @Nielsen_2016]. 

### LightGBM

LightGBM is a fairly recent implementation of parallel GBDT process which uses histogram-based approach and offers significant improvement in training time and memory usage. The winning solutions from recent machine learning challenges on Kaggle and benchmarking of various GBM from the researcher [@Pafka_2018] indicates that LightGBM outperforms XGBoost and other traditional algorithms in terms of accuracy as well. LightGBM was developed by Microsoft researchers in October 2016 and it is an open-source library available in R and Python both. 

### The mechanism behind improvised accuracy

The key difference between traditional algorithms and LightGBM algorithm is how trees are grown. Most decision tree learning algorithms controls the model complexity by depth and grow trees by level (depth-wise) as shown in the image below (image source ^[https://github.com/Microsoft/LightGBM/blob/master/docs/Features.rst#references]):

```{r depthwise, echo=FALSE, fig.height=3, out.width="65%", fig.cap= "Level-wise tree growth in most GBDT algorithms"}
include_graphics(path = "figure/depthwise.png")
```

In contrast, LightGBM algorithm uses best-first approach and grows tree leaf-wise. As a result, tree will choose the leaf with max delta loss to grow. According to [@MicrosoftCorporation_2018], holding the leaf fixed, leaf-wise algorithms are able to achieve better accuracy i.e. lower loss compared to level-wise algorithms.

```{r leafwise, echo=FALSE, fig.height=3, out.width="100%", fig.cap= "Leaf-wise tree growth in LightGBM algorithm"}
include_graphics(path = "figure/leafwise.png")
```
(image source ^[https://github.com/Microsoft/LightGBM/blob/master/docs/Features.rst#references])

Researcher [@Shi_2007] further explains the phenomena behind tree growth in best-first and depth-first approach and suggests that most decision tree learners expland nodes in depth-first order whereas best-first tree learners expand the best node whose split achieves maximum reduction of impurity among all the nodes available for splitting. Although the resulting tree will be same as depth-wise tree, the difference is in the order in which it grown. 

One of the key advantage of using LightGBM algorithm is that it offers good accuracy with label encoded categorical features instead of one hot encoded features. This eventually leads to faster training time. According to LightGBM documentation [@MicrosoftCorporation_2018], tree built on one-hot encoded features tends to be unbalanced and needs higher depth in order to achieve good accuracy in case of categorical features with high-cardinality. LightGBM implements Exclusive Feature Bundling (EFB) technique, which is based on research by [@D.Fisher_1958] to find the optimal split over categories and often performs better than one-hot encoding.

One disadvantage of leaf-wise approach is that it may cause over fitting when data is small. To overcome this issue, LightGBM includes the `max_depth` parameter to control model complexity however, trees still grow leaf-wise even when `max_depth` is specified [@MicrosoftCorporation_2018].

## Data preparation

To understand the characteristics of top 10 most active and violent terrorist groups, we filter the data and include all the countries that are impacted these groups as shown in the code chunk below:

```{r lgb_data_pre }
df_class <- df %>% 
  filter(group_name %in% top10_groups) %>%
  select(suicide_attack, year, month, day, region, country, 
         provstate, city, attack_type, target_type, weapon_type, 
         target_nalty, group_name, crit1_pol_eco_rel_soc, crit2_publicize, 
         crit3_os_intl_hmn_law, part_of_multiple_attacks, 
         individual_attack, attack_success, extended, 
         intl_logistical_attack, intl_ideological_attack, 
         nkill, nwound, arms_export, arms_import, population, 
         gdp_per_capita, refugee_asylum, refugee_origin, 
         net_migration, n_peace_keepers, conflict_index) %>%
  replace_na(list(nkill = 0, nwound = 0)) %>%
  na.omit()

```

## Overview of target variable

For this analysis, I have selected `suicide_attack` as a target variable. According to GTD codebook, this variable is coded “Yes” in those cases where there is evidence that the perpetrator did not intend to escape from the attack alive. From the plot and frequency table below, we can see that 11.3% incidents were observed as suicide attacks out of total 21,780 observations. 

```{r echo= FALSE, fig.height=4, fig.width=4, fig.cap="Overview of target variable: Suicide Attack"}
tmp <- df_class %>% 
  group_by(suicide_attack) %>% 
  summarize(count = n()) %>%
  mutate(suicide_attack = ifelse(suicide_attack == 1, "Yes", "No"))

ggplot(tmp, aes(x=suicide_attack, 
                y=count, fill = rev(factor(suicide_attack)))) + 
  geom_col(show.legend = "NA") + 
  xlab("Suicide Attack") +
  ggtitle("Target Variable") + 
  theme(axis.title = element_text(size=12), plot.title = element_text(size=12)) 
```

```{r echo=FALSE}
tmp <- as.factor(ifelse(df_class$suicide_attack == 1, "Yes", "No"))
knitr::kable(Freq(tmp), 
             booktabs = TRUE, 
             caption = "Frequency table for suicide attack variable")
```

## Feature engineering

Feature engineering is a process of creating representations of data that increase the effectiveness of a model [@Johnson_2018]. This is one of the most important aspect in machine learning that requires careful transformations and widening the feature space in order to imporve the performance of model. During data cleaning process, we have already taken care of missing values and NAs. With regard to LightGBM model, the primary requirement is to have all the variables in numeric. As discussed earlier, LightGBM offers good accuracy with label encoded categorical features compared to one-hot encoding method used in most algorithms. In this regard, we label encode all the categorical variables and specify them as a vector in model parameters. We also have numeric variables with extreme values such as arms_import, arms_export, nkill, nwound etc. For the modeling purpose, we use log transformation for such features. Last but not the least, we add frequency count features to widen the feature space. Frequency count features is known technique in machine learning competitions to improve the accuracy of the model. An example of feature with frequency is: number of attacks by group, year and region. Use of frequency count features adds more context to data and will be helpful to improve the performance of model. 


```{r}
#-------------------------------------------------------------
# Step 1: log transformation
#-------------------------------------------------------------
data <- df_class %>%  
  mutate(nkill = log1p(nkill + 0.01), 
         nwound= log1p(nwound + 0.01),
         arms_export = log1p(arms_export + 0.01),
         arms_import = log1p(arms_import + 0.01),
         population = log1p(population + 0.01))

#--------------------------------------------------------------
# Step 2: Add frequency count features
#--------------------------------------------------------------
data <- as.data.table(data)
data[, n_group_year:=.N,        by=list(group_name, year)]
data[, n_region_year:=.N,       by=list(region, year)]
data[, n_city_year:=.N,         by=list(city, year)]
data[, n_attack_year:=.N,       by=list(attack_type, year)]
data[, n_target_year:=.N,       by=list(target_type, year)]
data[, n_weapon_year:=.N,       by=list(weapon_type, year)]
data[, n_group_region_year:=.N, by=list(group_name, region, year)]
data[, n_group:=.N,             by=list(group_name)]
data[, n_provstate:=.N,         by=list(provstate)]
data[, n_city:=.N,              by=list(city)]
data <- as.data.frame(data)

#--------------------------------------------------------------
# Step 3: label encode categorical data (lightgbm requirement)
#--------------------------------------------------------------

features= names(data)
for (f in features) {
  if (class(data[[f]])=="character") {
    levels <- unique(c(data[[f]]))
    data[[f]] <- as.integer(factor(data[[f]], levels=levels))
  }
}

data[] <- lapply(data, as.numeric)
```

At this point, all of our variables are numeric and there are no missing values or NAs in this prepared data.

## Validation strategy

In general, cross-validation is the widely used approach to estimate peformance of the model. In this appoach, training data is split into equal sized (k) folds. The model is then trained on k-1 folds and performance is measured on remaining fold [@Johnson_2018]. However this approach is not suitable for our data. To further explain this, the observations in our dataset are time based so training the model on recent years (for example 2000- 2010) and evaluating the performance on previous years (for example 1980- 1990) would not be meaningful. To overcome this issue, we use time-based split to evaluate performance of our model. In other words, we use the observations in year 2016 as test set and remaining observations as our training set. 

This way we can be ensured that the model we have trained is capable of classifying target variable in current context. Following is the code used to implement validation strategy:

```{r}
# validation split
train <- data %>% filter(year <= 2015)
test  <- data %>% filter(year == 2016)
```

The next stage of process is to convert our data into lgb.Dataset format. During this process, we create a vector containing names of all our categorical variables and specify it while constructing lgb.Dataset as shown in the code below:

```{r}
# define all categorical features
cat_vars <- df %>% 
  select(year, month, day, region, country, 
         provstate, city, attack_type, target_type, weapon_type, 
         target_nalty, group_name, crit1_pol_eco_rel_soc, crit2_publicize, 
         crit3_os_intl_hmn_law, part_of_multiple_attacks, 
         individual_attack, attack_success, extended, 
         intl_logistical_attack, intl_ideological_attack, 
         conflict_index) %>% 
  names()

# construct lgb.Dataset and specify target variable and categorical features
dtrain = lgb.Dataset(
  data = as.matrix(train[, colnames(train) != "suicide_attack"]), 
  label = train$suicide_attack, 
  categorical_feature = cat_vars
  )

dtest = lgb.Dataset(
  data = as.matrix(test[, colnames(test) != "suicide_attack"]), 
  label = test$suicide_attack, 
  categorical_feature = cat_vars
  )

```

Notice that we have assigned labels separately to training and test data. To summarize the process, we will train the model on training data (dtrain), evaluate performance on test data (dtest). 

## Hyperparameter optimization

Hyperparameter tuning is a process of finding optimal value for the chosen model parameter. According to [@Johnson_2018], parameter tuning is an important aspect in modelling because they control the model complexity. And so that, it also affect any variance-base trade-off that can be made. There are several approaches for hyperparameter tuning such as Bayesian optimization, grid-search and randomized search. For this analysis, we used random grid-search approach for hyperparameter optimazation. In simple words, Randomized grid-search means we concentrate on the hyperparameter space that looks promising. This judgement often comes with prior experience of working with similar data. Several researchers [@Bergstra_2011; @Bergstra_2012] have also supported the randomized grid-search approach and have claimed that random search is much more efficient than any other approaches for optimizing the parameters.

For this analysis, we choose number of leaves, max depth, bagging franction, feature fraction and scale positive weight which are most important parameters to control the complexity of the model. As shown in the code chunk below, first we define a grid by specifying parameter and iterate over number of models in grids to find the optimal parameter values.

```{r}
set.seed(84)
# define chosen space in hyperparameter space
grid <- expand.grid(
  num_leaves        = c(5,7,9),
  max_depth         = c(4,6),
  bagging_fraction  = c(0.7,0.8,0.9),
  feature_fraction  = c(0.7,0.8,0.9),
  scale_pos_weight  = c(4,7) 
)

model <- list()
perf <- numeric(nrow(grid))

tic("Total time for random grid search: ")
for (i in 1:nrow(grid)) {
  # cat("Model ***", i , "*** of ", nrow(grid), "\n")
  model[[i]] <- lgb.train(
  	  list(objective         = "binary",
  	       metric            = "auc",
  	       learning_rate     = 0.01,
  	       num_leaves        = grid[i, "num_leaves"],
  	       max_depth         = grid[i, "max_depth"],
  	       bagging_fraction  = grid[i, "bagging_fraction"],
  	       feature_fraction  = grid[i, "feature_fraction"],
  	       scale_pos_weight  = grid[i, "scale_pos_weight"]),
	  dtrain,
	  valids = list(validation = dtest),
	  nthread = 4, 
	  nrounds = 5,
	  verbose= 0, 
	  early_stopping_rounds = 3
	)
  perf[i] <- max(unlist(model[[i]]$record_evals[["validation"]][["auc"]][["eval"]]))
  invisible(gc()) # free up memory after each model run
}
toc()

```

```{r}
#Extract results
cat("Model ", which.max(perf), " is with max AUC: ", max(perf), sep = "","\n")
best_params = grid[which.max(perf), ]

knitr::kable(best_params, booktabs = TRUE,
             caption = "Hyperparameter tuning result") %>%
		kable_styling(latex_options = "hold_position", font_size = 12, full_width = F)
```

From the hyperparameter tuning, we have extracted the optimized values based on AUC. Next, we use this parameters to in model building process. 

## Modelling

```{r}
# assign params from hyperparameter tuning result
params <- list(objective = "binary", 
               metric = "auc", 
               num_leaves = best_params$num_leaves,
               max_depth = best_params$max_depth,
               bagging_fraction = best_params$bagging_fraction,
               feature_fraction = best_params$feature_fraction,
               bagging_freq = 1,
               learning_rate = 0.01, 
               scale_pos_weight= best_params$scale_pos_weight)

model <- lgb.train(params, 
                   dtrain, 
                   valids = list(validation = dtest), 
                   nrounds = 1000, 
                   early_stopping_rounds = 50,
                   eval_freq = 100)

```


### Model evaluation

In order to evaluate the performance of our model on test data, we have use AUC metric which is commonly used in binary classification problem. From the trained model, we extract AUC score on test data from the best iteration with the code as shown below:

```{r}
cat("Validation AUC @ best iter: ", 
    max(unlist(model$record_evals[["validation"]][["auc"]][["eval"]])), "\n")
```

To deal with overfitting, we have specified early stopping criteria which stops the model training if no improvement is observed within specified rounds. At the best iteration, our model achieves 96.36% accuracy on validation data. To further investigate the error rate, we use confusion matrix. 

### Confusion Matrix

A confusion matrix is an another way to evaluate performance of binary classification model. 
```{r}
# get predictions on validation data
test_preds = predict(
  model, 
  data = as.matrix(test[, colnames(test) != "suicide_attack"]), 
  n = model$best_iter)

#table(test$suicide_attack)
confusionMatrix(
  data = as.factor(ifelse(test_preds > 0.5, 1, 0)), 
  reference = as.factor(test$suicide_attack))
```

Accuracy of 0.92 indicates that our model is 92% accurate. Out of all the metrics, the one we are most interested in is specitivity. We want our classifier to predict the "Yes"/ "1" instances of suicide attack more compared to "No"/"0" instances. To further explain this, as shown in the contingency table, our model has correctly predicted 582 out of 673 instances of "1"/ "Yes" in suicide attacks gives accuracy of 86.5%. 

### Feature importance

```{r}
# get feature importance
fi = lgb.importance(model, percentage = TRUE)
knitr::kable(head(fi, 10), booktabs = TRUE,
            caption = "Feature importance matrix") %>%
		kable_styling(latex_options = "hold_position", font_size = 12, full_width = F)
```

Gain is the most important measure for predictions and represents feature contribution to the model. This is calculated by comparing contribution of each feature for each tree in the model. The Cover metric indicates number of observations related to particular feature. The Frequency measure is the percentage representing the relative number of times a particular feature occurs in the trees of the model. In simple words, it tells us how often the feature is used in the model [@Chen_2018; @Pandya_2018].

From the feature importance matrix, we can see that type of weapon contributes the most in terms of gain followed by number of people killed, province state, type of attack and type of target. In order to allow the model to decide whether an attack will be a suicide attack or not, these features are the most important compared to others. 

## Model interpretation

To further analyse reasoning behind model's decision making process, we randomly select one observation from test data and compare it with the predicted value based on features contribution. 

```{r}
# extract test data without transformation
tmp_test <- df_class %>% filter(year == 2016)
# Extract second observation
knitr::kable(
  t(tmp_test[2, ]), booktabs= TRUE,
  caption = "Actual values in 2nd observation in test set") %>%
		kable_styling(latex_options = "hold_position", font_size = 12, full_width = F)
```

Next, we extract the predicted value from the model and use lgb.interprete function to compute feature contribution components of rawscore prediction. 

```{r}
cat(paste("predicted value from model: ", test_preds[[2]]))

#extract interpretation for 2nd observation in (transformed) test data
tree_interpretation <- lgb.interprete(model, data = as.matrix(test[, colnames(test)]), 2)
lgb.plot.interpretation(tree_interpretation[[1]])
```

As shown in the plot above, the decision making process behind making prediction for second observation in test is based on contribution of above features. The negative value indicates contradiction and positive value represents support. Although nkill and weapon_type variables are one of most important features based on gain however their contribution toward prediction is negative. Same way, province, city, attack type and attack success features contributes positive toward prediction. 


