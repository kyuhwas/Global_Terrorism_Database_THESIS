# Time-series Forecasting {#time-series}

Time-series forecasting is a supervised machine learning approach that uses historical data to predict future occurrences. This is particularly helpful in terrorism context for long-term strategic planning. For this analysis, the forecasting goal and corresponding data are chosen as below: 

```{r echo=FALSE}
text_tbl <- data.frame(
  'Forecasting_Goal' = c("Predict future number of attacks", "Predict future number of fatalities", "Predict future number of attacks"),
  'Frequency' = c("By Months", "By Months", "By Months"),
  'Chosen_Country'= c("Afghanistan", "Iraq", "SAHEL region")
)

if( knitr:::is_latex_output() ) {
  knitr::kable(text_tbl, caption = "Scope of analaysis", booktabs = TRUE) %>%
    kable_styling(full_width = F, latex_options = "HOLD_position")
} else {
  knitr::kable(text_tbl, caption = "Scope of Analaysis") %>%
    kable_styling(full_width = F, font_size = 13) %>%
    column_spec(2:3, background = "#e1e5f2")
}
```

For each analysis, first, we select the appropriate data, examine seasonal components and then split the data in training and test set to evaluate the performance of Auto Arima, Neural Network, TBATS and ETS models with seven different metrics. To examine whether an ensemble prediction can improve the overall accuracy, we take the average of all the predictions and compute Theil’s U statistic. In the last part of the analysis, we use all the data points (train + test) to make a forecast for the chosen future period. 

## Afghanistan (Predict future attacks)

### Data preparation

Based on exploratory data analysis, it is observed that the number of attacks with visible pattern began from the year 2000 so the data is selected between the year 2000 to 2016. To get the time-series frequency by months for all the years, we use `complete` function from tidyr package to turn implicit missing values into explicit missing values. In other words, we add missing months and assign zero as shown in the code below: 

```{r}
dft <- df %>%
  filter(year >= 2000 & country == "Afghanistan") %>%
  group_by(year, month) %>%
  summarise(total_count = n()) %>%
  ungroup() %>%
  group_by(year) %>%
  # Add missing months and assign 0 where no occurences
  tidyr::complete(month = full_seq(seq(1:12), 1L), 
                  fill = list(total_count = 0)) %>%
  ungroup()

dft <- dft %>%
  mutate(month_year = paste(year, month, sep="-"),
         month_year = zoo::as.yearmon(month_year)) %>%
  select(month_year, total_count)

# Create a ts object
dft <- ts(dft[, 2], 
          start = Year(min(dft$month_year)), 
          frequency = 12) # 1=annual, 4=quartly, 12=monthly

dft <- na.kalman(dft)
```

### Seasonality analysis

First, we take a look at time plot to get an idea about how a number of attacks have changed over the period of time. In the plot below, observations (number of attacks) are plotted against the time of observation. 

```{r echo= FALSE, fig.cap= "Attack frequency by year- Afghanistan" ,fig.height=3, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/afg_line_plot.png")
} else {
  ts_plot(dft, line.mode = "line", Xtitle = "Year", Ytitle = "Attack Counts", 
    title = "Attack frequency (Afghanistan)", color = "red")
}
```

The seasonal plot is similar to time plot above with seasonality component (i.e. months) in which the number of attacks were observed.

```{r echo= FALSE, fig.cap= "Seasonal pattern within year- Afghanistan", fig.height=4, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/afg_seasonal.png")
} else {
  ts_seasonal(dft, type = "cycle", Ygrid = T, Xgrid = T,
    title = "Seasonality plot (Afghanistan)") 
}
```
From the seasonal patterns within a year, as shown in the plot above, we can see that year 2015 (followed by 2012) was the deadliest year in terms of number of terror attacks. In both years, the spike is visible in May month. 

```{r echo= FALSE, fig.cap= "Seasonal pattern (boxplot)- Afghanistan", fig.height=4, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/afg_box.png")
} else {
  ts_seasonal(dft, type = "box", Ygrid = T, Xgrid = T, title = "Seasonality plot (Afghanistan)") 
}
```

From the boxplot, we can confirm that the May month contributes the most in terms of terrorist incidents throughout all the years (2000-2016) in Afghanistan. We can see the upward trend in a number of attacks starting from February and reaching a peak in May month. 

Decomposition by additive and multiplicative time-series is helpful to describe the trend and seasonal component within data. This also helps understand anomalies in data as shown in the plot below:  

```{r echo= FALSE, fig.cap= "Time-series decomposition- Afghanistan", fig.height=5, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/afg_decompose.png")
} else {
  ts_decompose(dft, type = "both") 
}
```

Time-series decomposition comprises three components depending on observed patterns: 

- a seasonal component, 
- a trend-cycle component and
- a remainder component 

The seasonal component as shown in the plot above represents a pattern that occurs frequently within a fixed period of time. Trend-cycle contains both trend and cycle and a remainder component contains everything else in the time-series. The remainder component is also called random component/ noise and it represents residuals of the original time-series after removing seasonal and trend component [@Anomaly.io_2015; @Hyndman_2018].   


### Correlation test

There are several methods to identify a correlation between series and lags such as ACF, PACF and lag plots. In a lag plot, two variables are lagged and presented in scatterplot manner. In simple words, lag means a fixed amount of time from time-series data. We use lag plots method for this analysis which allows us to quickly visualize three things:

- outliers 
- randomness and 
- auto-correlation.  

The plot as shown below represents nine different lags. Although we can see a few outliers but there is no randomness in data. To further explain this, we can see the positive linear trend going upward from left to right in all nine plots. The positive linear trend is an indication that positive auto-correlation is present in our data. 

```{r echo= FALSE, fig.cap= "Correlation test", fig.height=3, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/afg_lags.png")
} else {
  ts_lags(dft, lag.max = 9) 
}
```

Specifically, lags 1, 2, 3 and 9 show strong positive auto-correlation. Presence of auto-correlation can be problematic for some models. 


### Modelling

In this part of the analysis, we split the data in training and test set in order to evaluate the performance of four different models before making the actual forecasts. 

#### Train-Test Split

```{r}
set.seed(84)

# horizon (look ahead period)
horizon <- 12

# crete split for train and test set
data <- ts_split(dft, sample.out = horizon)

# Split the data into training and testing sets
train <- data$train
test  <- data$test
```

We have chosen 12 months look ahead period (horizon) so the test set contains the last 12 months from our data i.e. all the months in the year 2016 on which we will be evaluating the performance of the model. 

\pagebreak


#### Auto Arima

```{r}
fit_arima <- auto.arima(train)
```

```{r echo= FALSE, fig.height=5, out.width="100%", fig.cap="Auto Arima: residuals"}
# plot the residuals
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/afg_residuals.png")
} else {
  check_res(fit_arima) 
}
```

A quick look at residuals from Auto Arima suggests that the mean of residuals is very close to zero however from the histogram, we can see that residuals don’t follow the normal distribution. What this means is, forecasts from this method will probably be quite good but prediction intervals computed assuming a normal distribution may be inaccurate [@Hyndman_2018].

```{r}
# Accuracy check/ Forecast evaluation
fc_arima <- forecast(fit_arima, h = horizon)
```

```{r echo= FALSE, fig.height=3, out.width="100%", fig.cap="Auto Arima: Actual vs Fitted vs Forecasted"}
#plot actual vs fitted and forecasted
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/afg_arima_fitted.png")
} else {
  test_forecast(actual = dft, forecast.obj = fc_arima, test = test) %>% 
  layout(legend = list(x = 0.1, y = 0.9)) 
}
 
```
From the plot above, it is observed that the Auto Arima model nearly captures fitted values based on training data but forecasted values are a little bit apart from actual values (test data- year 2016). 

Next, we examine the pattern in actual vs fitted and forecasted values for the remaining three models. 

#### Neural Network
```{r}
fit_nn <- nnetar(train, repeats = 5)
# Accuracy check/ Forecast evaluation 
fc_nn <- forecast(fit_nn, h = horizon)
```

```{r echo= FALSE, fig.height=3, out.width="100%", fig.cap="Neural Net: Actual vs Fitted vs Forecasted"}
#plot actual vs fitted and forecasted
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/afg_nn_fitted.png")
} else {
  test_forecast(actual = dft, forecast.obj = fc_nn, test = test) %>% 
  layout(legend = list(x = 0.1, y = 0.9))  
}
```

\vspace{18pt}


#### TBATS  
```{r}
fit_tbats <- tbats(train)
# Accuracy check/ Forecast evaluation 
fc_tbats <- forecast(fit_tbats, h = horizon)
```

```{r echo=FALSE, fig.height=3, out.width="100%", fig.cap="TBATS: Actual vs Fitted vs Forecasted"}
#plot actual vs fitted and forecasted
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/afg_tbats_fitted.png")
} else {
  test_forecast(actual = dft, forecast.obj = fc_tbats, test = test) %>% 
  layout(legend = list(x = 0.1, y = 0.9))   
}
```

\vspace{36pt}

#### ETS
```{r}
fit_ets <- ets(train)
# Accuracy check/ Forecast evaluation 
fc_ets <- forecast(fit_ets, h = horizon)
```

```{r echo=FALSE, fig.height=3, out.width="100%", fig.cap="ETS: Actual vs Fitted vs Forecasted"}
#plot actual vs fitted and forecasted
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/afg_ets_fitted.png")
} else {
  test_forecast(actual = dft, forecast.obj = fc_ets, test = test) %>% 
  layout(legend = list(x = 0.1, y = 0.9))   
}
```

### Evaluating models' Performance

To compare the performance of all four models on test data, I have extracted mean accuracy from each model and have arranged the models by MAPE metric which is most commonly used. We will also look at six other metrics to get a better idea of the model’s performance. 

Out of all the seven metrics, as shown in the table below, ME (Mean Error), RMSE (Root Mean Squared Error) and MAE (Mean Absolute Error) are a scale-dependent error. Whereas MPE (Mean Percentage Error) and MAPE (Mean Absolute Percent Error) are percentage errors and ACF stands for first-order correlation. Researchers [@Hyndman_2018] suggest that percentage errors have the advantage of being unit-free, and so are frequently used to compare forecast performances between data sets. 


```{r}
metrics  <- rbind(as.data.frame(round(accuracy(fc_arima$mean, test), 3)),
                  as.data.frame(round(accuracy(fc_nn$mean, test), 3)),
                  as.data.frame(round(accuracy(fc_tbats$mean, test), 3)),
                  as.data.frame(round(accuracy(fc_ets$mean, test), 3))) %>% 
  add_column(models = c("Auto Arima", "NeuralNet", "TBATS", "ETS"), 
             .before = "ME") %>% 
  arrange(MAPE)
```

```{r echo=FALSE}
if( knitr:::is_latex_output() ) {
  knitr::kable(metrics, booktabs = TRUE, 
    caption = "Performance comparison of all models (Afghanistan)") %>% 
    kable_styling(full_width = F, latex_options = "HOLD_position", 
                  font_size = 12)
} else {
  knitr::kable(metrics, 
    caption = "Performance comparison of all models (Afghanistan)") %>% 
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, 
                  font_size = 13) %>%
    column_spec(1, bold = T, color = "black") %>%
    column_spec(2:8, color = "black", background = "#dee2ed") %>%
    column_spec(6, color = "black", background = "#c7cfe5") %>%
    row_spec(1, background = "#c7cfe5") 
}
```

Based on MAPE metrics, we can see that TBATS and ETS models achieve the higher accuracy (~ 15) and out performs Auto Arima and Neural Network models. TBATS (Exponential Smoothing State Space Model With Box-Cox Transformation) and ETS (Exponential Smoothing State Space Model) both use exponential smoothing method. Specifically, TBATS modeling approach offers several key advantages such as handling of typical nonlinear features and allowing any auto-correlation in the residuals to be taken into account [@Livera_2011].

In addition to MAPE metric which is chosen to identify the best model, we also look at **Theil’s U statistic** to estimate how good or bad the model is. In simple words, Theil’s U-statistic compares the performance of the model with naïve/ random walk model(U=1). If Theil’s U statistic value equals one, it means that the model forecasting method is as good as naïve model (guessing). A value greater than one means the forecasting method is even worst than guessing. Similarly, the value less than 1 indicates that the forecasting method is better than naïve model and worth considering [@Oracle_]. 

From the comparison, we can see that all four models have Theil’s U score less than one while TBATS and ETS models having a comparatively good score of 0.6 compared to Neural Network at 0.95.

### Ensemble

As stated in the literature review, many research focuses on a single model approach or using the best single model out of all the models. Instead of throwing out weak models, I employ simple ensemble approach (averaging predictions of all four models) to improve the overall accuracy on the test set. This is one of the well-known approach used in machine learning competitions such as on Kaggle [@JacobvanVeen_2015]. Following is the code used to extract predictions from all four models and then new column "ensemble" is added which take the average of all models. Next, we calculate Theil’s U score on ensemble predictions using a simple function in DescTools package by supplying actual observations and predicted observations as shown below: 

```{r}
# extract predictions from all four models and get average
ensemble <- rowMeans(
  cbind(fc_arima$mean, fc_nn$mean, fc_tbats$mean, fc_ets$mean))

# Compute Theil's U statistic (a = actual values, p= predicted values)
cat(paste("Theil's U score on Ensemble: ", 
          round(TheilU(a = test, p = ensemble),3)))

```

Although TBATS model is our best single model however ensemble predictions by averaging forecasts of other weak models is even better. We can see that the ensemble approach significantly improves the overall accuracy as measured by Theil’s U score of 0.2. The most recent theoretical framework also supports the ensemble approach in time-series forecasting. Researchers [@Hyndman_2018], in their book "Forecasting: Principles and Practice", suggests that using several different methods on the same time-series data and then averaging the results of forecast often guarantees better performance than any single best models. 

To summarize, it is possible that TBATS model may not be the best model on other data, however, use of ensemble approach and corresponding Theil’s U score can be used in time-series forecasting to improve the accuracy and justify the reliability of final predictions. 


### Forecast future number of attacks

As we have evaluated the performance of all four models, the next step of the process is to generate a forecast using all the data points i.e 2000-2016. The forecast horizon can be changed based on business requirement and by observing the predictions. As shown in the code chunk below, first we will generate forecasts from all four models and then we will visualize the results with plots. 

```{r}
f_horizon <- 18
# run model on full data
fore_arima <- forecast(auto.arima(dft), h = f_horizon, level = c(80, 95))
fore_nn <- forecast(nnetar(dft, repeats = 5), h = f_horizon, 
                    level = c(80, 95), PI = TRUE)
fore_tbats <- forecast(tbats(dft), h = f_horizon, level = c(80, 95))
fore_ets <- forecast(ets(dft), h = f_horizon, level = c(80, 95))
```


```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Auto Arima forecast (Afghanistan)"}
if( knitr:::is_latex_output() ) {
  autoplot(fore_arima) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 2, out.width="100%", fig.cap="Neural Network forecast (Afghanistan)"}
if( knitr:::is_latex_output() ) {
  autoplot(fore_nn) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="TBATS forecast (Afghanistan)"}

if( knitr:::is_latex_output() ) {
  autoplot(fore_tbats) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="ETS forecast (Afghanistan)"}

if( knitr:::is_latex_output() ) {
  autoplot(fore_ets) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Auto Arima forecast (Afghanistan)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_arima$mean), ymin = fore_arima$lower[, 2], 
                ymax = fore_arima$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_arima$mean), ymin = fore_arima$lower[, 1], 
                ymax = fore_arima$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_arima$mean), y = fore_arima$mean, 
              color = I("orange"), name = "Arima") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```


```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Neural Network forecast (Afghanistan)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_nn$mean), ymin = fore_nn$lower[, 2], 
                ymax = fore_arima$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_nn$mean), ymin = fore_nn$lower[, 1], 
                ymax = fore_arima$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_nn$mean), y = fore_nn$mean, 
              color = I("orange"), name = "Neural Network") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```



```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="TBATS forecast (Afghanistan)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_tbats$mean), ymin = fore_tbats$lower[, 2], 
                ymax = fore_arima$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_tbats$mean), ymin = fore_tbats$lower[, 1], 
                ymax = fore_tbats$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_tbats$mean), y = fore_tbats$mean, 
              color = I("orange"), name = "TBATS") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="ETS forecast (Afghanistan)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_ets$mean), ymin = fore_ets$lower[, 2], 
                ymax = fore_ets$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_ets$mean), ymin = fore_ets$lower[, 1], 
                ymax = fore_ets$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_ets$mean), y = fore_ets$mean, 
              color = I("orange"), name = "ETS") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```

The forecasting results are often represented by the mean value and by confidence interval of 80% and 95%. The mean value of the forecast is considered as final forecasting value. Next, we extract forecasts for the chosen horizon and add the ensembled predictions as predicted future attacks in Afghanistan.

```{r}
tbl_arima   <- timetk::tk_tbl(round(fore_arima$mean)) 
tbl_nn      <- timetk::tk_tbl(round(fore_nn$mean))
tbl_tbats   <- timetk::tk_tbl(round(fore_tbats$mean))
tbl_ets     <- timetk::tk_tbl(round(fore_ets$mean))

tbl <- tbl_arima %>% 
    left_join(tbl_nn, by = "index") %>% 
    left_join(tbl_tbats, by = "index") %>% 
    left_join(tbl_ets, by = "index")

names(tbl) <- c("Time_period", "Arima", "NN", "TBATS", "ETS")
tbl$Ensemble <- round(rowMeans(tbl[,2:5]))
```

```{r echo=FALSE}
if( knitr:::is_latex_output() ) {
  knitr::kable(tbl, booktabs = TRUE, 
    caption = "Table of predicted future number of attacks in Afghanistan") %>% 
    kable_styling(full_width = F, latex_options = "HOLD_position") 
} else {
  knitr::kable(tbl, caption = "Table of predicted future number of attacks in Afghanistan") %>% 
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, 
                  font_size = 13, position = "left") %>%
    column_spec(1:5, color = "black", background = "#dee2ed") %>%
    column_spec(1, bold = T) %>%
    column_spec(6, bold = T, color = "black", background = "#c7cfe5")   
}
```


## Iraq (Predict future fatalities)

For this analysis, we use the exact same approach as before to estimate the number of fatalities in Iraq. 

### Data preparation

I have selected the data from 2004 to 2016 to make it appropriate for the modeling. Wherever an incident is part of multiple attacks, we have different reported figures from different sources. To overcome this issue, I have grouped data on specific variables and then taken the maximum reported value as shown in the code chunk below:

\vspace{18pt}

```{r}
dft <- df %>%
  filter(year >= 2004 & country == "Iraq") %>%
  replace_na(list(nkill = 0)) %>% 
  group_by(group_name, region, year, month) %>% 
  filter(if_else(part_of_multiple_attacks == 1, 
                 nkill == max(nkill), nkill == nkill)) %>%
  ungroup() %>%
  distinct(group_name, region, country, year, month, nkill,
  		   nwound, part_of_multiple_attacks) %>%
  group_by(year, month) %>%
  summarise(total_count = sum(nkill)) %>%
  ungroup() %>%
  group_by(year) %>%
  # Add missing months and assign 0 where no occurence
  tidyr::complete(month = full_seq(seq(1:12), 1L), 
                  fill = list(total_count = 0)) %>%
  ungroup()

dft <- dft %>%
  mutate(month_year = paste(year, month, sep="-"),
         month_year = zoo::as.yearmon(month_year)) %>%
  select(month_year, total_count)

# Create a ts object
dft <- ts(dft[, 2], 
          start = Year(min(dft$month_year)), 
          frequency = 12) # 1=annual, 4=quartly, 12=monthly

dft <- na.kalman(dft)
```

### Seasonality analysis

\vspace{18pt}

```{r echo=FALSE, fig.cap= "Fatalities frequency by year- Iraq", fig.height=3, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/iraq_line_plot.png")
} else {
  ts_plot(dft, line.mode = "line", Xtitle = "Year", Ytitle = "Fatalities Counts", 
          title = "Fatalities frequency (Iraq)", color = "red")
}
```

From the time plot above, we can see an unusual spike indicating 2426 deaths in June 2014. This refers to the major incidents from ISIL where 1500 people were reportedly killed in a single incident followed by another single incident involving 600 deaths.

```{r echo=FALSE, fig.cap= "Seasonality Plots - Iraq", fig.height=7, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/iraq_seasonal.png")
} else {
  ts_seasonal(dft, type = "all", Ygrid = T, Xgrid = T, title = "Seasonality Plots (Iraq)") 
}
```

From the seasonal components, we can see that the number of fatalities is higher during mid-year. Specifically, July month accounts the most followed by April and May month. An interesting observation from the second plot above is that the variation in the number of fatalities by months between the year 2008 and 2013 is quite steady. Whereas in the years following 2013, we can see an upward trend as well as the noticeable difference in a number of fatalities by months. 

From the boxplot, we can also see extreme outliers (in the statistical term) in June, August and October month indicating the very high number of fatalities in single incidents. 

### Correlation test

```{r echo=FALSE, fig.cap= "Correlation test", fig.height=5, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/iraq_lags.png")
} else {
  ts_lags(dft, lag.max = 9) 
}
```

From the lag plot, we can see the slightly positive linear pattern as well as few outliers in all nine lags however there is no randomness in data. The linear pattern also suggests that auto-correlation is present. In statistical terms, correlation means the extent of a linear relationship between two variables. Same way, auto-correlation means the linear relationship between lagged values of a time series as shown in the plot above. 


### Modelling

```{r}
set.seed(84)
# horizon (look ahead period)
horizon <- 18

# crete split for train and test set
data <- ts_split(dft, sample.out = horizon)
# Split the data into training and testing sets
train <- data$train
test  <- data$test

# Run models
fit_arima <- auto.arima(train)
fit_nn <- nnetar(train, repeats = 5)
fit_tbats <- tbats(train)
fit_ets <- ets(train, lambda = BoxCox.lambda(train))

#Get validation forecasts
fc_arima <- forecast(fit_arima, h = horizon)
fc_nn <- forecast(fit_nn, h = horizon)
fc_tbats <- forecast(fit_tbats, h = horizon)
fc_ets <- forecast(fit_ets, h = horizon)

metrics  <- rbind(as.data.frame(round(accuracy(fc_arima$mean, test), 3)),
                  as.data.frame(round(accuracy(fc_nn$mean, test), 3)),
                  as.data.frame(round(accuracy(fc_tbats$mean, test), 3)),
                  as.data.frame(round(accuracy(fc_ets$mean, test), 3))) %>% 
  add_column(models = c("Auto Arima", "NeuralNet", "TBATS", "ETS"), 
             .before = "ME") %>% 
  arrange(MAPE)
```

```{r echo=FALSE}
if( knitr:::is_latex_output() ) {
  knitr::kable(metrics, booktabs = TRUE, 
    caption = "Performance comparison of all models (Iraq)") %>% 
    kable_styling(full_width = F, latex_options = "HOLD_position", 
                  font_size = 12)
} else {
  knitr::kable(metrics, 
    caption = "Performance comparison of all models (Iraq)") %>% 
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, 
                  font_size = 13) %>%
    column_spec(1, bold = T, color = "black") %>%
    column_spec(2:8, color = "black", background = "#dee2ed") %>%
    column_spec(6, color = "black", background = "#c7cfe5") %>%
    row_spec(1, background = "#c7cfe5")
}

```

From the model comparison based on MAPE metric, we can see that Auto Arima model performs better on this data. The corresponding Theil’s U score is ~ 0.8 for all the models which mean forecasts from the chosen model are better than random guessing. 

Next, we calculate Theil’s U score on ensembled predictions to see how much improvement can be achieved compared to the best single model. 

### Ensemble

```{r}
# extract predictions from all four models and create ensemble
preds <- as.data.frame(
  cbind(fc_arima$mean, fc_nn$mean, fc_tbats$mean, fc_ets$mean))
preds$ensemble <- rowMeans(preds)

# Compute Theil's U statistic (a = actual values, p= predicted values)
cat(paste("Theil's U score on Ensemble: ", 
          round(TheilU(a = test, p = preds$ensemble),3)))
```

As expected, we can see the significant improvement in forecasting accuracy by averaging predictions from all four models. Just to re-iterate, Theil’s U score less than 1 means predictions are better than a random guess (naive model). 


### Forecast future fatalities

In the validation part, data was into train and test in order to evaluate the performance of different models. For the forecast, we run the models all the data points.

```{r}
# look ahead period 
f_horizon <- 12
# run model on full data
fore_arima <- forecast(auto.arima(dft), h = f_horizon, level = c(80, 95))
fore_nn <- forecast(nnetar(dft, repeats = 5), h = f_horizon, 
                    level = c(80, 95), PI = TRUE)
fore_tbats <- forecast(tbats(dft), h = f_horizon, level = c(80, 95))
fore_ets <- forecast(ets(dft, lambda = BoxCox.lambda(dft)), 
                     h = f_horizon, level = c(80, 95))
```


```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Auto Arima forecast (Iraq)"}

if( knitr:::is_latex_output() ) {
  autoplot(fore_arima) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Neural Network forecast (Iraq)"}

if( knitr:::is_latex_output() ) {
  autoplot(fore_nn) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="TBATS forecast (Iraq)"}

if( knitr:::is_latex_output() ) {
  autoplot(fore_tbats) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="ETS forecast (Iraq)"}

if( knitr:::is_latex_output() ) {
  autoplot(fore_ets) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Auto Arima forecast (Iraq)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_arima$mean), ymin = fore_arima$lower[, 2], 
                ymax = fore_arima$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_arima$mean), ymin = fore_arima$lower[, 1], 
                ymax = fore_arima$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_arima$mean), y = fore_arima$mean, 
              color = I("orange"), name = "Auto Arima") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```


```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Neural Network forecast (Iraq)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_nn$mean), ymin = fore_nn$lower[, 2], 
                ymax = fore_arima$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_nn$mean), ymin = fore_nn$lower[, 1], 
                ymax = fore_arima$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_nn$mean), y = fore_nn$mean, 
              color = I("orange"), name = "Neural Network") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```



```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="TBATS Forecast (Iraq)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_tbats$mean), ymin = fore_tbats$lower[, 2], 
                ymax = fore_arima$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_tbats$mean), ymin = fore_tbats$lower[, 1], 
                ymax = fore_tbats$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_tbats$mean), y = fore_tbats$mean, 
              color = I("orange"), name = "TBATS") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="ETS Forecast (Iraq)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_ets$mean), ymin = fore_ets$lower[, 2], 
                ymax = fore_ets$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_ets$mean), ymin = fore_ets$lower[, 1], 
                ymax = fore_ets$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_ets$mean), y = fore_ets$mean, 
              color = I("orange"), name = "ETS") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```



```{r}
tbl_arima   <- timetk::tk_tbl(round(fore_arima$mean)) 
tbl_nn      <- timetk::tk_tbl(round(fore_nn$mean))
tbl_tbats   <- timetk::tk_tbl(round(fore_tbats$mean))
tbl_ets     <- timetk::tk_tbl(round(fore_ets$mean))

tbl <- tbl_arima %>% 
    left_join(tbl_nn, by = "index") %>% 
    left_join(tbl_tbats, by = "index") %>% 
    left_join(tbl_ets, by = "index")

names(tbl) <- c("Time_period", "Arima", "NN", "TBATS", "ETS")
tbl$Ensemble <- round(rowMeans(tbl[,2:5]))
```

```{r echo=FALSE}
if( knitr:::is_latex_output() ) {
  knitr::kable(tbl, booktabs = TRUE, 
    caption = "Table of predicted future fatalities in Iraq") %>%
    kable_styling(full_width = F, latex_options = "HOLD_position", 
                  font_size = 12)
} else {
  knitr::kable(tbl, 
    caption = "Table of predicted future fatalities in Iraq") %>%
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, 
                  font_size = 13, position = "left") %>%
    column_spec(1:5, color = "black", background = "#dee2ed") %>%
    column_spec(1, bold = T) %>%
    column_spec(6, bold = T, color = "black", background = "#c7cfe5")
}
```

We can see flat forecast in ETS and TBATS model on this data which means that the trend and seasonality are insufficient to allow the future observations to have different conditional means for that model. In that case, both models return the last observed value. We also computed the Theil’s U score for ensemble on test set which is ~ 0.39. By using the ensembled approach and corresponding Theil’s U score during model evaluation, we can ensure the reliability of forecasted values on unseen data. 



## SAHEL Region (Predict future attacks)

The Sahel region in Africa stretches from east to west across the African continent. At present, this region draws huge political attention due to the indications of possible geographical expansion of ISIL [@Liautaud_2018]. To estimate the future number of attacks in this region, I have selected data from the year 2000 and filtered by eight countries that fall within the sahel region as shown in the data preparation step. 

### Data preparation

```{r}
sahel_region <- c("Mauritania", "Mali", "Burkina Faso", 
                  "Niger", "Nigeria", "Chad", "Sudan", "Eritrea")

dft <- df %>%
  filter(year >= 2000 & country %in% sahel_region) %>%
  group_by(year, month) %>%
  summarise(total_count = n()) %>%
  ungroup() %>%
  group_by(year) %>%
  tidyr::complete(month = full_seq(seq(1:12), 1L), fill = list(total_count = 0)) %>%
  ungroup()

dft <- dft %>%
  mutate(month_year = paste(year, month, sep="-"),
  month_year = zoo::as.yearmon(month_year)) %>%
  select(month_year, total_count)

# Create a ts object
dft <- ts(dft[, 2], start = Year(min(dft$month_year)), 
          frequency = 12) # 1=annual, 4=quartly, 12=monthly
dft <- na.kalman(dft)
```

### Seasonality analysis

```{r echo= FALSE, fig.cap= "Attack frequency by year- SAHEL Region", fig.height=3, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/sahel_line_plot.png")
} else {
  ts_plot(dft, line.mode = "line", Xtitle = "Year", Ytitle = "Attack Counts", 
          title = "Attack frequency (SAHEL region)", color = "red")
}
```

From the attack frequency by year, it is observed that the number of attacks have increased exponentially in the last decade and reaching a peak during the year 2014-2015. Several researchers [@Crone_2017; @Onuoha_2018] have indicated that Boko Haram affiliated itself with Islamic State in 2015 as well as a large number of small groups from the entire region have also declared their affiliation with Islamic State.

```{r echo= FALSE, fig.cap= "Seasonal pattern (heatmap) - SAHEL Region", fig.height=3, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/sahel_heatmap.png")
} else {
  ts_heatmap(dft)
}
```

From the heatmap above, we can see a sudden increase in a number of attacks from the year 2012 and more than 50 attacks a month on average. Let’s have a look at seasonal components to see if there is any pattern by cycles. 

```{r echo= FALSE, fig.cap= "Seasonality pattern (boxplot) - SAHEL Region", fig.height=4, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/sahel_boxplot.png")
} else {
  ts_seasonal(dft, type = "box", Ygrid = T, Xgrid = T, 
              title = "Seasonality plot (SAHEL region)") 
}
```

In a comparison to a number of attacks in Afghanistan and number of fatalities in Iraq, we can see opposite trend in SAHEL region where months in the beginning and end of the year (Jan to Mar and Oct to Dec) indicates a higher number of attacks through the period (2000-2016). In the case of Afghanistan and Iraq, it was mostly observed in the months middle of the year.

### Correlation test

```{r echo= FALSE, fig.cap= "Correlation test", fig.height=5, out.width= "100%"}
if( knitr:::is_latex_output() ) {
  include_graphics(path = "figure/sahel_lags.png")
} else {
  ts_lags(dft, lag.max = 9) 
}
```

Similar to correlation tests in Iraq and Afghanistan, a positive linear trend is visible in all nine lags while lag 1 and 2 suggesting strong auto-correlation. 

### Modelling

```{r}
set.seed(84)
# horizon (look ahead period)
horizon <-  18

# crete split for train and test set
data <- ts_split(dft, sample.out = horizon)
# Split the data into training and testing sets
train <- data$train
test  <- data$test

# Run models
fit_arima <- auto.arima(train)
fit_nn <- nnetar(train, repeats = 5)
fit_tbats <- tbats(train)
fit_ets <- ets(train)
```

```{r echo=FALSE}
#Get validation forecasts
fc_arima <- forecast(fit_arima, h = horizon)
fc_nn <- forecast(fit_nn, h = horizon)
fc_tbats <- forecast(fit_tbats, h = horizon)
fc_ets <- forecast(fit_ets, h = horizon)

metrics  <- rbind(as.data.frame(round(accuracy(fc_arima$mean, test), 3)),
                  as.data.frame(round(accuracy(fc_nn$mean, test), 3)),
                  as.data.frame(round(accuracy(fc_tbats$mean, test), 3)),
                  as.data.frame(round(accuracy(fc_ets$mean, test), 3))) %>% 
  add_column(models = c("Auto Arima", "NeuralNet", "TBATS", "ETS"), 
             .before = "ME") %>% 
  arrange(MAPE)
```


```{r echo=FALSE}
if( knitr:::is_latex_output() ) {
  knitr::kable(metrics, booktabs = TRUE, 
    caption = "Performance comparison of all models (SAHEL Regioin)") %>% 
    kable_styling(full_width = F, latex_options = "HOLD_position", 
                  font_size = 12)
} else {
  knitr::kable(metrics, 
    caption = "Performance comparison of all models (SAHEL Regioin)") %>%  
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, 
                  font_size = 13) %>%
    column_spec(1, bold = T, color = "black") %>%
    column_spec(2:8, color = "black", background = "#dee2ed") %>%
    column_spec(6, color = "black", background = "#c7cfe5") %>%
    row_spec(1, background = "#c7cfe5")
}
```

From the model comparison based on MAPE metric, we can see that Auto Arima followed by Neural Network performs better on this data and all four models having Theil’s U score below 1. 

### Ensemble

```{r}
# extract predictions from all four models and get average
ensemble <- rowMeans(cbind(fc_arima$mean, fc_nn$mean, fc_tbats$mean, fc_ets$mean))
# Compute Theil's U statistic (a = actual values, p= predicted values)
cat(paste("Theil's U score on Ensemble: ", 
          round(TheilU(a = test, p = ensemble),3)))
```

An ensemble prediction further improves the prediction accuracy as measured by Theil’s U score. 

### Forecast future attacks

```{r}
# look ahead period 
f_horizon <- 18
# run model on full data
fore_arima <- forecast(auto.arima(dft), h = f_horizon, level = c(80, 95))
fore_nn <- forecast(nnetar(dft, repeats = 5), h = f_horizon, 
                    level = c(80, 95), PI = TRUE)
fore_tbats <- forecast(tbats(dft), h = f_horizon, level = c(80, 95))
fore_ets <- forecast(ets(dft), h = f_horizon, level = c(80, 95))
```


```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Auto Arima forecast (SAHEL Region)"}

if( knitr:::is_latex_output() ) {
  autoplot(fore_arima) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Neural Network forecast (SAHEL Region)"}

if( knitr:::is_latex_output() ) {
  autoplot(fore_nn) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="TBATS forecast (SAHEL Region)"}

if( knitr:::is_latex_output() ) {
  autoplot(fore_tbats) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="ETS forecast (SAHEL Region)"}

if( knitr:::is_latex_output() ) {
  autoplot(fore_ets) + theme(legend.position="none", plot.title = element_text(size=12))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Auto Arima forecast (SAHEL Region)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_arima$mean), ymin = fore_arima$lower[, 2], 
                ymax = fore_arima$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_arima$mean), ymin = fore_arima$lower[, 1], 
                ymax = fore_arima$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_arima$mean), y = fore_arima$mean, 
              color = I("orange"), name = "Auto Arima") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```


```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="Neural Network forecast (SAHEL Region)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_nn$mean), ymin = fore_nn$lower[, 2], 
                ymax = fore_arima$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_nn$mean), ymin = fore_nn$lower[, 1], 
                ymax = fore_arima$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_nn$mean), y = fore_nn$mean, 
              color = I("orange"), name = "Neural Network") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```


```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="TBATS forecast (SAHEL Region)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_tbats$mean), ymin = fore_tbats$lower[, 2], 
                ymax = fore_arima$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_tbats$mean), ymin = fore_tbats$lower[, 1], 
                ymax = fore_tbats$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_tbats$mean), y = fore_tbats$mean, 
              color = I("orange"), name = "TBATS") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```

```{r echo= FALSE, fig.height= 3, out.width="100%", fig.cap="ETS forecast (SAHEL Region)"}
# get individual plots (interactive) for html output
if(!knitr:::is_latex_output() ) {
  plot_ly() %>%
    add_lines(x = time(dft), y = dft,
              color = I("#487caf"), name = "Actual") %>%
    add_ribbons(x = time(fore_ets$mean), ymin = fore_ets$lower[, 2], 
                ymax = fore_ets$upper[, 2],
                color = I("gray90"), name = "95% confidence") %>%
    add_ribbons(x = time(fore_ets$mean), ymin = fore_ets$lower[, 1], 
                ymax = fore_ets$upper[, 1],
                color = I("gray85"), name = "80% confidence") %>%
    add_lines(x = time(fore_ets$mean), y = fore_ets$mean, 
              color = I("orange"), name = "ETS") %>%
    layout(legend = list(x = 0.1, y = 0.9))
}
```

From the plots above, we can see that Auto Arima, Neural Network, and TBATS model are able to capture observed trend whereas the ETS model fails and generates flat predictions. However, the ensemble approach will compensate for the loss from any weak models as computed before. 

```{r}
tbl_arima   <- timetk::tk_tbl(round(fore_arima$mean)) 
tbl_nn      <- timetk::tk_tbl(round(fore_nn$mean))
tbl_tbats   <- timetk::tk_tbl(round(fore_tbats$mean))
tbl_ets     <- timetk::tk_tbl(round(fore_ets$mean))

tbl <- tbl_arima %>% 
    left_join(tbl_nn, by = "index") %>% 
    left_join(tbl_tbats, by = "index") %>% 
    left_join(tbl_ets, by = "index")

names(tbl) <- c("Time_period", "Arima", "NN", "TBATS", "ETS")
tbl$Ensemble <- round(rowMeans(tbl[,2:5]))
```

```{r echo=FALSE}
if( knitr:::is_latex_output() ) {
  knitr::kable(tbl, booktabs = TRUE, 
    caption = "Table of predicted future number of attacks in SAHEL Region") %>% 
    kable_styling(full_width = F, latex_options = "HOLD_position", 
                  font_size = 12)
} else {
  knitr::kable(tbl, 
    caption = "Table of predicted future number of attacks in SAHEL Region") %>% 
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, 
                  font_size = 13, position = "left") %>%
    column_spec(1:5, color = "black", background = "#dee2ed") %>%
    column_spec(1, bold = T) %>%
    column_spec(6, bold = T, color = "black", background = "#c7cfe5")
}
```

\par

**Summary**

To summarize this chapter, we analyzed the seasonality components within time-series at the monthly frequency for Afghanistan, Iraq and SAHEL region. We found an upward trend in a number of attacks starting from February to May month in Afghanistan throughout all the years. Similarly, in Iraq, we found higher fatalities during July month followed by April and May month. Whereas in the SAHEL region, this pattern is completely the opposite. 

From the time-series forecasting models, we estimated the future number of attacks and fatalities using four different models at a monthly frequency. We also illustrated the importance of using ensemble method and evaluated predicted vs actual values using Theil’s U statistic which indicates a significant improvement in forecasting accuracy than the best single model. Comparing the same models on different time-series data indicates that the best single model in one time-series data may not be the best single model in another time-series data. 

Apart from prediction at a monthly frequency, and forecasting number of attacks and fatalities, the scope of this analysis can be further extended predict number of injuries, quarterly frequency and for any country using the shiny app which is also an integral part of this research. 

